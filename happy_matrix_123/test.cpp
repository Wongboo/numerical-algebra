//
// Created by 王波 on 2020/11/12.
//

#include <predefine.hpp>
#include <random>
#include <chrono>

using namespace happy_matrix;
using namespace std;



template<typename T>
vector<T> operator+(const matrix<T> &left, const vector<T> &right) {
    vector<T> out(left.size());
//#pragma omp parallel for shared(left, right, out) default(none)
    for (size_t i = 0; i < left.size(); i++)
#pragma GCC ivdep
//#pragma clang loop vectorize(enable)
#pragma loop( ivdep )
            for (size_t j = 0; j < right.size(); j++)
                out[i] += left[i][j] * right[j];
    return out;
}

int main(){
    using T = float;
    constexpr size_t size = 10000;
    matrix<T> to_decompose(size, vector<T>(size));
    vector<T> to_solve(size);
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(-1.0, 1.0);

    for (size_t i = 0; i < size; ++i){
        if (i != 0)
            to_decompose[i][i - 1] = to_decompose[i - 1][i]= 1;
        to_decompose[i][i] = 10;
    }

    for (size_t i = 0; i < size; ++i) {
        // Use dis to transform the random unsigned int generated by gen into a
        // T in [-1, 1). Each call to dis(gen) generates a new random T
        to_solve[i] = dis(gen);
    }

    auto start = chrono::high_resolution_clock::now();
    auto solved = to_decompose + to_solve;
    auto end = chrono::high_resolution_clock::now();
    chrono::duration<double> time = end -start;
    cout << solved[0] << " " << time.count() << endl;

    start = chrono::high_resolution_clock::now();
    solved = to_decompose * to_solve;
    end = chrono::high_resolution_clock::now();
    time = end -start;
    cout << solved[0] <<  " " << time.count() << endl;

    start = chrono::high_resolution_clock::now();
    solved = to_decompose + to_solve;
    end = chrono::high_resolution_clock::now();
    time = end -start;
    cout << solved[0] <<  " " << time.count() << endl;

    start = chrono::high_resolution_clock::now();
    solved = to_decompose * to_solve;
    end = chrono::high_resolution_clock::now();
    time = end -start;
    cout << solved[0] <<  " " << time.count() << endl;

    start = chrono::high_resolution_clock::now();
    solved = to_decompose + to_solve;
    end = chrono::high_resolution_clock::now();
    time = end -start;
    cout << solved[0] <<  " " << time.count() << endl;

    start = chrono::high_resolution_clock::now();
    solved = to_decompose * to_solve;
    end = chrono::high_resolution_clock::now();
    time = end -start;
    cout << solved[0] <<  "+" << time.count() << endl;
}

