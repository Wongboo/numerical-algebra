//
// Created by 王波 on 2020/11/12.
//

#include <predefine.hpp>
#include <iostream>
#include <random>
#include <chrono>

using namespace happy_matrix;
using namespace std;

template<typename T>
vector<T> operator+(const matrix<T> &left, const vector<T> &right) {
    vector<T> out(left.size());
    constexpr size_t size = sizeof(T) == 4 ? 4 : sizeof(T) == 8 ? 2 : 1;
#pragma omp parallel for shared(left, right, out)\
    default(none) num_threads(omp_get_num_procs() / 2)
    for (int i = 0; i < left.size(); i++){
        T s(0);
#pragma clang loop vectorize(enable)
#pragma loop( ivdep )
#pragma GCC ivdep
        for (size_t j = 0; j < right.size(); j++)
            s += left[i][j] * right[j];
        out[i] = s;
    }
    return out;
}

auto multiply(vector<float> a, vector<float> b){
    auto s = a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
    return s;
}

int main(){
    using T = float;
    constexpr size_t size = 10000;
    matrix<T> to_decompose(size, vector<T>(size));
    vector<T> to_solve(size);
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_real_distribution<> dis(-1.0, 1.0);

    for (size_t i = 0; i < size; ++i){
        if (i != 0)
            to_decompose[i][i - 1] = to_decompose[i - 1][i]= 1;
        to_decompose[i][i] = 10;
    }

    for (size_t i = 0; i < size; ++i) {
        // Use dis to transform the random unsigned int generated by gen into a
        // T in [-1, 1). Each call to dis(gen) generates a new random T
        to_solve[i] = dis(gen);
    }

    //vector<float> a {1.f, 2.f, 3.f, 4.f};
    //vector<float> b { 3.f, 1.f, 2.f,4.f};
    //b[0] = dis(gen);
    //cout << multiply(a, b);
    auto start = chrono::high_resolution_clock::now();
    auto solved = to_decompose + to_solve;
    auto end = chrono::high_resolution_clock::now();
    chrono::duration<double> time = end -start;
    cout << solved[0] << " " << time.count() << endl;

    start = chrono::high_resolution_clock::now();
    solved = to_decompose * to_solve;
    end = chrono::high_resolution_clock::now();
    time = end -start;
    cout << solved[0] <<  " " << time.count() << endl;

    start = chrono::high_resolution_clock::now();
    solved = to_decompose + to_solve;
    end = chrono::high_resolution_clock::now();
    time = end -start;
    cout << solved[0] <<  " " << time.count() << endl;

    start = chrono::high_resolution_clock::now();
    solved = to_decompose * to_solve;
    end = chrono::high_resolution_clock::now();
    time = end -start;
    cout << solved[0] <<  " " << time.count() << endl;

    start = chrono::high_resolution_clock::now();
    solved = to_decompose + to_solve;
    end = chrono::high_resolution_clock::now();
    time = end -start;
    cout << solved[0] <<  " " << time.count() << endl;

    start = chrono::high_resolution_clock::now();
    solved = to_decompose * to_solve;
    end = chrono::high_resolution_clock::now();
    time = end -start;
    cout << solved[0] <<  "+" << time.count() << endl;
}

